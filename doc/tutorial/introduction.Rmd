Writing your own wrapper is also possible, and not too complicated. You must provide several callback functions. The most complex part will be provide functions to read and write the model. As a starter, you might want to look into the wrappers, **SVMBridge** provides. 

# SVM Parameter


Every SVM has some parameter, tha usually must be tuned. While LIBSVM has (for RBF kernel) two prominent parameter, the regularization term $C$ and the kernel bandwidth $\gamma$, this might not be true for other methods. For example, Budgeted SVM operates with $\lambda$ instead of $C$, with $\lambda = \frac{1}{2 C}$, and the $\gamma$ is twice the gamma of LIBSVM. Because of this, **SVMBridge** does not have a prebuild set of parameters. Every wrapper is free to use the parameter it needs. This entails that to use a wrapper, you must first know which parameter it uses. You can use the help function to get a description of a wrapper.


LIBSVMHelp() { }


# Training


Training can be either performed from data in memory (probably the most useful case), from the file system by using the ```trainSVM``` function. 
Note: In case you specify data from memory and from disc, **SVMBridge** will throw an error, as it will be confused about which source to use.


# Testing

Testing is done very similar to training by calling the ```testSVM``` function You have the option to use data from memory, from file system. Furthermore, predictions can be provided. By default, the predictions are written into a temporary file and are discarded after testing. 
Note: In case you specify data from memory and from disc, **SVMBridge** will throw an error, as it will be confused about which source to use.


# Model file

If you do not specify any model file for training, ```trainSVM``` will ask R for a temporary file and will provide this path to the SVM package. Internally, the ```writeModel``` routine of the SVM package will be used to create a model file from a model in memory.  In case you have not specified a model file path, after training the model will be read from the temporary model file into the SVM Results Object. Contrary, if you did specify a model file path, then by default, the model is not read back into the SVM Results Object. To enforce reading the model, you can set the argument ```readModel``` to true. 

At testing time, you must provide the trained model. If you pass this as an in-memory model, ```testSVM``` will call the ```readModel``` routine of the SVM package first to dump the model to a temporary file on the filesystem. 

skipModel == TRUE

```splus
library(SVMBridge)
```

# Predictions

After testing, the predictions will again be stored in the SVM Object and can be accessed by e.g. ```SVMObj$predictions```. Depending on the purpose, the predictions are not always needed, for example when tuning the SVM parameters. To avoid extra I/O and memory consumption, reading back the predictions can be turned of by using the ```skipPredictions``` options. By default, ```skipPredictions``` is false, so ```callSVM``` will return the predictions in the SVM Object.

skipPredictions == TRUE



# Writing your own wrapper

The method name will define all function names! This is very important, if you do not abide to this rule, callSVM will not find the corresponding callbacks! Suppose you want to write a wrapper for mySVM. In this case, you will need to create a file exactly called "mySVM_wrapper.R'. Please note that the filename is case-sensitive. This is also true for all the callback functions. 

Your mySVM software must be split into two parts: Training and Testing. This might be the same executable, but be aware, that testing must work without training data. In case your package needs testing data at training time (e.g. if the model only specifies the index of the support vector in the training file instead of copying them into the model), you need to perform quite heavy tricks to get this going. In general, using other packages and skip **SVMBridge** might be a good idea, as **SVMBridge** strictly follows the LIBSVM way of training and testing. 


## The training parameters

You will get a bunch of parameters. You will need to decide which ones you want to handle. E.g. the LIBSVM wrapper handles $C$, $\gamma$ and $\epsilon$, but also uses $kernelCacheSize$. On the other hand, the LIBSVM wrapper currently has no option to control the shrinking, although LIBSVM has a parameter for this. Similarly you will need to decide, whether you want the user to have control over all parameters or only a relevant subset. The callback will then gather all the parameter and create a command-line string.


# SVM Result Object

Actually we do enforce that.
We do not enforce a structure on the returned SVM Return Object. Nonetheless, we encourage you to use the same structure we have provided in our example wrapper, if that is applicable to your case. The SVM Return Object contains the following fields: 
 -execTime
 -error
Depending on training or testing, this is the training or testing time, measured in wall time by microbenchmark. 


## Test parameters

Very similar to training parameters, the test parameter callback will assemble a given model file and test data and possibly other options.


extraParameters for testing??


# Data Formats

As nearly all SVM Packages work with the LIBSVM/SVMlight Sparse Format, this is the basic file format in SVMBridge. Notice that SVMBridge actually does neither enforce nor check this explicitly. You can support your own data format for your own SVM wrapper. In this case, keep in mind that other SVM packages might not be able to work with your data. 

To implement your own data format, recall that you have two ways to provide data to your SVM software. The first is by specifiying a path to a data file on the filesystem. In this case, SVMBridge will not explicitly work with the data, so you are free to use any format, as long as your SVM software can handle this. The second way is to pass data as a matrix to the SVMBridge. Here, SVMBridge needs to dump the given data first. By default, the SVMBridge will write the data in the LIBSVM Sparse Format. You are free to overwrite this behaviour, by rewriting the convertData function of the SVM Wrapper Object.

Let us give an easy example.

LABELS..
MULTICLASS..


# Vocabulary

The SVM software is the compiled object on the file system, e.g. when you download and compile LIBSVM you will end  up with two binaries, one for training, one for testing. These files is an SVM software for us.

Glue code that handles controlling the SVM software is called an SVM wrapper. This contains e.g. routines for reading and writing an SVM model.

Finally, an SVM package is for us the internal object in the SVMBridge, that has basically consists of the wrapper and the software (e.g. a path to the binary).



## Speed

It is possible to bypass any extra-I/O and directly communicate with the SVM Package by specifying the training and test data as well as the model and prediction as a file. If SVMBridge gets file pathes, it will not try to reread the written model nor the predictions. Sometimes you do not need the predictions, neither on memory nor on disk. In this case you can pass "/dev/null" as prediction file. This will make the SVM Test write to null, so it will not take any I/O time,  and therefore the SVMBridge will not reread the predictions, as it was already written on disk.
