#!/usr/bin/Rscript  --vanilla 

#
# SVMBridge 
#
#		(C) 2015, by Aydin Demircioglu
# 
# SVMBridge is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SVMBridge is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# Please do not use this software to destroy or spy on people, environment or things.
# All negative use is prohibited.
#
  
#source ("./universalWrapper.R")
createTrainingArguments.BVM = function (x, 
					trainDataFile = "",
                                            modelFile = "",
                                            extraParameter = "",
                                            primalTime = 10, 
                                            wallTime = 8*60,
                                            kernelCacheSize = 1024,
                                            cost = 1, 
                                            gamma = 1, 
                                            epsilon = 0.001, ...) {

    args = c(
        "-s 6",                         # CVM = 6, BVM = 9
        "-t 2",
        sprintf("-c %.16f", cost), 
        sprintf("-m %d", kernelCacheSize), # in MB 
        sprintf("-g %.16f", gamma),
        sprintf("-e %.16f", epsilon),
        extraParameter,
        trainDataFile,
        modelFile
    )

    return (args)
}



createTestArguments.BVM = function (x,
					testDataFile = "",
                                        modelFile = "", ...) {
    args = c(
        testDataFile,
        modelFile,
        "/dev/null"                     # outfile, not needed
    )
    
    return (args)
}



extractTrainingInfo.BVM = function (x, output) {

    # maybe not the best way to grep the string
    pattern <- "Accuracy = (\\d+\\.?\\d*).*"
    err = 1 - as.numeric(sub(pattern, '\\1', output[grepl(pattern, output)])) / 100
    
    return (err)
}


#NEW
extractTestInfo.BVM = function (x, output) {

    # maybe not the best way to grep the string
    pattern <- "Accuracy = (\\d+\\.?\\d*).*"
    err = 1 - as.numeric(sub(pattern, '\\1', output[grepl(pattern, output)])) / 100
    
    return (err)
}


readModel.LIBSVM = function (x, modelFile = './model', verbose = FALSE) {
		if (verbose == TRUE) {
			BBmisc::messagef ("Reading LIBSVM model from %s.", modelFile)
		}
		
		# open connection
		con  <- file(modelFile, open = "r")

		while ((oneLine <- readLines(con, n = 1, warn = FALSE)) != "SV") {
			# gamma value
			if (grepl("gamma", oneLine) == TRUE) {
				pattern <- "gamma (.*)"
				gamma = as.numeric(sub(pattern, '\\1', oneLine[grepl(pattern, oneLine)])) 
			}  
		
			# rho/bias
			if (grepl("rho", oneLine) == TRUE) {
				pattern <- "rho (.*)"
			bias = as.numeric(sub(pattern, '\\1', oneLine[grepl(pattern, oneLine)])) 
			}
			
			# order of labels
			if (grepl("label", oneLine) == TRUE) {
				pattern <- "label (.*)"
				order = (sub(pattern, '\\1', oneLine[grepl(pattern, oneLine)])) 
			
				if ((order != "1 -1") && (order != "-1 1")) {
					stop ("Label ordering %s is unknown!", order)
				}
				# LABEL ORDERING IS NOT USED for libsvm!
			}  
		}
	
	
		# read and interprete data 
		# basically all data is sparse data format, but the data around this differs
		svmatrix = readSparseFormat(con)

	
		# add header information
		svmatrix$gamma = gamma
		svmatrix$bias = bias
		svmatrix$modelname = "LIBSVM"
		
		# close connection
		close(con)
		
		# return
		return (svmatrix)
	}

#readModel.BVM <- function (x, modelFile = "./model", verbose = FALSE) {
#	LIBSVMReadModelCallBack (modelFile = modelFile, verbose = verbose)
#}



writeModel.BVM <- function (x, model = NA, modelFile = "./model", verbose = FALSE) {
	LIBSVMWriteModelCallBack (model = model, modelFile = modelFile, verbose = verbose)
}
 

 
#
# @param[in]	predictionsFile		file to read predictions from
# @return		array consisting of predictions
#

readPredictions.BVM <- function (predictionsFilePath = "", verbose = FALSE) {
	return (LIBSVMPredictionsCallBack (predictionsFilePath = predictionsFilePath, verbose = verbose))
}

findSoftware.BVM = function (x, searchPath = "./", verbose = FALSE) {

		if (verbose == TRUE) {
			BBmisc::messagef("    LASVM Object: Executing search for software for %s", x$method)
		}
		
		trainBinaryPattern = "^svm-train$"
		trainBinaryOutputPattern = 'bvm-train .options. training_set_file .model_file.'
		binaryPath = findBinary (searchPath, trainBinaryPattern, trainBinaryOutputPattern, verbose = verbose)

		# TODO: check for empty path+handling
		
		if (verbose == TRUE) {
			BBmisc::messagef("--> Found train binary at %s", binaryPath) 
		}
		x$trainBinaryPath = binaryPath


		testBinaryPattern = "^svm-predict$"
		testBinaryOutputPattern = "bvm-predict .options. test_file model_file output_file"

		binaryPath = findBinary (searchPath, testBinaryPattern, testBinaryOutputPattern, verbose = verbose)
		
		# TODO: check for empty path+handling

		if (verbose == TRUE) {
			BBmisc::messagef("--> Found test binary at %s", binaryPath) 
		}
		x$testBinaryPath = binaryPath

		return(x)
	}




#NEW
#findSoftware.BVM = function(x, searchPath = "./", verbose = FALSE) {
#		# short way without verbose messages
#		x$trainBinaryPath  = findBinary (searchPath, "^svm-train$", "outputPattern = '6 -- CVM \\(sqr. hinge-loss", verbose = verbose)
#	}
