# tries to sequentially accept proposed points. points which are located too close to design
# points or already accepted proposed points are dropped and replaced by random points.
#
# input:
#   prop  [list] : list of proposed points, as generated by proposePoints
# output  [list] : same format as input, but some points replaced

filterProposedPoints = function(prop, opt.path, par.set, control) {
  # prepare stuff
  n = nrow(prop$prop.points)
  design = getOptPathX(opt.path)
  calcMaxMetric = function(x, y) max(abs(x - y))
  to.delete = rep(FALSE,  n)

  # look at min distance from i-point to current set (design + accepted)
  for (i in 1:n) {
    pp = prop$prop.points[i, ]
    min.dist = min(apply(design, 1, calcMaxMetric, y = pp))
    # if too close, mark i-point, otherwise add it to set
    if (min.dist < control$filter.proposed.points.tol)
      to.delete[i] = TRUE
    else
      design = rbind(design, pp)
  }

  # for now replace removed design points with random points,
  #  we leave all other data in prop like it is, we have flag filter.replace
  n.replace = sum(to.delete)
  prop$filter.replace = to.delete

  if (n.replace > 0) {
    # FIXME: we might want to do something smarter here. how about augmenting the current design?
    prop$prop.points[to.delete, ] = generateRandomDesign(n.replace, par.set)
  }

  return(prop)
}
